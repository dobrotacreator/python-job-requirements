#       ОБЯЗАТЕЛЬНЫЕ
# **PythonCore**

1. ## **_Типы данных_** **_и_** **_их примеры_**
    
2. ## **_Расскажи внутреннее устройство словаря_**
    
3. ## **_Какие проблемы возникают при использовании хеш-таблицы и способы их решения_**
    
4. ## **_Какие типы данных использовала из модуля collection_**
    orderedict, defaultdict, namedtuple, counter
5. ## **_Что такое декоратор?_**
    
6. ## **_Какие декораторы приходилось писать?_**
    
7. ## **_Что такое контекстные менеджеры?_**
    Контекстные менеджеры - это объекты, которые позволяют управлять контекстом выполнения определенного кода, предоставляя возможность автоматически выполнять операции при входе в контекст и при выходе из него.
8. ## **_Приходилось ли использовать свои контекстные менеджеры?_**       
	```python
	class MyContextManager:
	    def __enter__(self):
	        # Код, выполняемый при входе в контекст
	        print("Entering the context")
	        # Здесь вы можете выполнить любые операции, которые должны произойти при входе в контекст
	    def __exit__(self, exc_type, exc_value, exc_traceback):
	        # Код, выполняемый при выходе из контекста
	        print("Exiting the context")
	        # Здесь вы можете выполнить любые операции, которые должны произойти при выходе из контекста 
	        # Использование собственного контекстного менеджера
	with MyContextManager():
	    # Здесь находится код, который будет выполняться внутри контекста
	    print("Inside the context")
	```
9. ## **_Для чего используются_** _**Лямбда**__-__**функции**_**_?_**
    
10. ## **_Что такое генераторы и итераторы?_**
    
11. ## **_Как можно создать генератор?_**
    
12. ## **_Как можно создать итератор?_**
    ```python
    class PowTwo:
	    def __init__(self, max=0):
	        self.max = max
	    def __iter__(self):
	        self.n = 0
	        return self
	    def __next__(self):
	        if self.n <= self.max:
	            result = 2 ** self.n
	            self.n += 1
	            return result
	        else:
	            raise StopIteration
	```
13. ## **_Назови десять встроенных функций._**
   - Встроенные функции, выполняющие преобразование типов
   - abs(x); all(последовательность)
   - dir([object])
   - enumerate(iterable, start=0)
   - filter(function, iterable)
   - hash(x)
   - input([prompt]) 
   - id(object)
   - isinstance(object, ClassInfo) 
   - len(x)
   - iter(x)
14. ## **_Какие принципы ООП ты знаешь в_** **_Python?_**
    
15. ## **_Что такое мета-классы?_**
    
16. ## **_Какие стандартные модули приходилось использовать?_**
	- `os` — модуль для работы с операционной системой (файлы, папки, пути, переменные среды);
	- `sys` — модуль для работы с интерпретатором Python;
	- `datetime` — модуль для работы с датами и временем;
	- `math` — модуль для выполнения математических операций;
	- `random` — модуль для генерации случайных чисел;
	- `csv` — модуль для работы с файлами CSV;
	- `json` — модуль для работы с данными в формате JSON;
	- `re` — модуль для работы с регулярными выражениями;
	- `urllib` и `requests` — модули для работы с HTTP-запросами;
	- `smtp` — модуль для отправки электронных писем.
---

# **Устройство интерпретатора**

1. ## **_Что такое GIL?_**
    
2. ## **_В чем плюсы и минусы_** **_GIL_** **_на твой взгляд?_**
    
3. ## **_Как добиться реальной параллельности в_** **_Python_** **_коде?_**
    
4. ## **_В чем разница асинхронного и многопоточного кода?_**
    
5. ## **_Какие проблемы многопоточности ты знаешь?_**
    
6. ## **_В каких ситуация и что лучше использовать асинхронность, многопоточность и мультипроцессорность?_**
    
7. ## **_Что такое сборщик мусора и как он работает?_**
    
8. ## **_Какие проблемы есть с подсчётом ссылок и как они решаются в питоне?_**
    
9. ## **_Как работает механизм аллоцирования памяти в питоне?
	![[Pasted image 20230622151841.png]]
10. ## **_Как происходит процесс удаления из памяти?_**
    
11. ## **_Как работает сборщик мусора в связке GIL?_**
    
---

# **Принципы написания кода**

1. ## **_SOLID_**
    
2. ## **_KISS_**
    
3. ## **_DRY_**
    
4. ## **_YAGNI_**
    
---

# **RESTful API / HTTP** **и** **HTTPs**

1. ## **_Что такое_** **_http_** **_и_** **_https и чем они отличаются?_**
    
2. ## **_Модель клиент-серверного общения_**
    
3. ## **_Что такое_** **_REST_** **_и его принципы?_**
    REST (Representational State Transfer) - это архитектурный стиль, который определяет набор принципов и ограничений для разработки распределенных систем. REST является основой для проектирования веб-служб, API и других систем, обеспечивая простоту, масштабируемость и надежность.
    
	Принципы REST включают в себя:
	
	1) **Клиент-серверная архитектура**: Система разделена на клиентов (инициирующие запросы) и серверы (обеспечивающие ресурсы и обрабатывающие запросы). Это позволяет независимо развивать и масштабировать клиентскую и серверную части системы.
	    
	2) **Без состояния (Stateless)**: Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для выполнения запроса. Сервер не должен сохранять состояние клиента между запросами. Это упрощает масштабирование системы и повышает ее надежность.
	    
	3) **Кэширование**: Серверы могут указывать клиентам, что определенные ресурсы могут быть кэшированы. Клиенты могут использовать кэшированные данные, если они являются актуальными. Кэширование помогает улучшить производительность и снизить нагрузку на сервер.
	    
	4) **Единообразие интерфейса**: REST предоставляет унифицированный интерфейс для взаимодействия между клиентом и сервером. Это включает использование стандартных методов HTTP, таких как GET, POST, PUT и DELETE для работы с ресурсами. Кроме того, REST ставит акцент на идентификацию ресурсов через уникальные URI (Uniform Resource Identifiers).
	    
	5) **Слои (Layered System)**: Клиенты могут взаимодействовать с сервером через промежуточные слои, такие как кэши, балансировщики нагрузки или прокси-серверы. Это обеспечивает модульность и упрощает добавление новых функциональных возможностей.
	    
	6) **Код по требованию (Optional)**: Сервер может предоставлять код (например, JavaScript), который выполняется на стороне клиента. Это позволяет клиентам расширять функциональность системы, получая код от сервера.
4. ## **_Какие ты знаешь_** **_http_** **_методы и за что каждый из них отвечает?_**
    
---

# **Django**

1. **_Какие плюсы и минусы_** **_Django_** **_ты можешь выделить?_**
    
2. **_Что такое_** **_ORM_** **_и его плюсы и минусы?_**
    
3. **_Что такое_** **_n+1 проблема и как она решается в Django?_**
    
    Проблема "n+1" (также известная как проблема "1+N") возникает при выполнении запросов к базе данных, когда вместо выполнения единственного запроса для получения данных, необходимых для работы приложения, выполняется дополнительный запрос для каждого элемента (n) в результате первоначального запроса.
	В контексте Django проблема "n+1" часто возникает при использовании отношений ForeignKey или ManyToManyField. Например, если у нас есть модель `Author`, связанная с моделью `Book` через ForeignKey, и мы хотим получить всех авторов и список их книг, неэффективный подход может привести к проблеме "n+1".
	Для решения проблемы "n+1" в Django можно использовать механизм "жадной загрузки" (eager loading), который позволяет получить все необходимые данные в одном запросе. В Django для этого можно использовать метод `select_related` или `prefetch_related` при выполнении запросов.
	В этом примере, используя `select_related('book_set')`, мы выполняем "жадную загрузку" связанных объектов `book_set` вместе с авторами. Теперь все данные получаются в одном запросе, что позволяет избежать проблемы "n+1" и улучшает производительность запросов к базе данных.
	Аналогично, `prefetch_related` можно использовать для решения проблемы "n+1" при работе с ManyToManyField и другими типами связей.
4. **_Приходилось ли использовать функции агрегации? Для чего используются методы annotate и  aggregate?_**
	
	Методы `annotate()` и `aggregate()` используются для выполнения агрегаций данных в запросах к базе данных в Django.
	1. **Метод** `annotate()`:
	    - `annotate()` используется для добавления агрегированных значений к каждому объекту в результате запроса.
	    - Он позволяет вычислять агрегированные значения, такие как сумма, среднее, минимум, максимум и т. д., и добавлять их в каждый объект результирующего набора.
	    - Пример:
		```python
			from django.db.models import Sum
			from myapp.models import Order
			orders = Order.objects.annotate(total_price=Sum('price'))
		```
	    - В этом примере, `annotate()` добавляет агрегированное значение `total_price`, которое представляет сумму цен (`price`) всех заказов, к каждому объекту заказа.
	2. **Метод** `aggregate()`:
	    - `aggregate()` используется для вычисления агрегированных значений по всем объектам в результате запроса.
	    - Он позволяет вычислять агрегированные значения и возвращать их в виде отдельного результата запроса.
	    - Пример:
			```python
			from django.db.models import Avg
			from myapp.models import Product
			avg_rating = Product.objects.aggregate(average_rating=Avg('rating'))
			```
	    - В этом примере, `aggregate()` вычисляет среднюю оценку (`rating`) всех продуктов и возвращает ее в виде результата запроса.
	Использование методов `annotate()` и `aggregate()` позволяет проводить агрегации данных в запросах к базе данных, что полезно, когда требуется получить суммарные, средние или другие агрегированные значения на основе данных в моделях Django.
5. **_Приходилось ли использовать Q и F выражения?_**
    1) **Выражение Q**:
        - Выражение Q (Query) позволяет создавать сложные условия для фильтрации объектов в запросах к базе данных.
        - Он используется для объединения нескольких условий с использованием логических операторов И (`&`), ИЛИ (`|`) и НЕ (`~`).
        - `Q` может быть использован как аргумент в методах `filter()`, `exclude()` и других методах запросов.
        - Пример:
			```python
				from django.db.models import Q
				from myapp.models import Product
				products = Product.objects.filter(Q(price__lt=100) | Q(name__icontains='apple'))
			```
			
        - В этом примере, `filter()` использует выражение `Q`, чтобы получить все продукты с ценой меньше 100 или содержащие в имени слово "apple".

    2) **Выражение F**:
	    - Выражение F (Field) позволяет использовать значения полей модели внутри запросов, в том числе для сравнения, математических операций и обновления значений полей.
	    - Он позволяет работать с полями модели непосредственно на уровне базы данных, вместо извлечения их в Python для дальнейшей обработки.
	    - `F` может использоваться в методах `filter()`, `update()` и других методах запросов.
	    - Пример:
			```python
			from django.db.models import F
			from myapp.models import Product
			products = Product.objects.filter(price__gt=F('discounted_price'))
			```
	    - В этом примере, `filter()` использует выражение `F`, чтобы получить все продукты, у которых цена (`price`) больше, чем скидочная цена (`discounted_price`).
	
	Использование Q- и F-выражений позволяет создавать более сложные и гибкие запросы к базе данных в Django, включая условия с использованием логических операторов и работу с значениями полей модели. Это особенно полезно, когда требуется построить запросы с динамически определяемыми условиями или использовать значения полей модели внутри запросов.
6. **_Как сделать GROUPBY с помощью Django ORM?_**
	
	В Django ORM для выполнения операции GROUP BY можно использовать метод `values()` в сочетании с методом `annotate()`. Вот примеры использования:
	1) **Простой GROUP BY**:
		```python
		from django.db.models import Count
		`from myapp.models import Product
		# Выбираем все продукты и группируем их по полю 'category'
		grouped_products = Product.objects.values('category').annotate(total=Count('id'))
		```
		В этом примере мы выбираем все продукты и группируем их по полю 'category'. Метод `values('category')` указывает, что мы хотим группировать по полю 'category'. Затем мы используем метод `annotate(total=Count('id'))`, чтобы добавить агрегированное значение 'total', которое представляет количество продуктов в каждой группе.
	2) **GROUP BY с условием WHERE**:
		```python
		from django.db.models import Count
		from myapp.models import Product
		# Выбираем все продукты с ценой больше 100 и группируем их по полю 'category'
		grouped_products = Product.objects.filter(price__gt=100).values('category').annotate(total=Count('id'))
		```
		В этом примере мы выбираем только те продукты, у которых цена больше 100, и группируем их по полю 'category'. Затем мы используем метод `annotate(total=Count('id'))`, чтобы добавить агрегированное значение 'total' - количество продуктов в каждой группе.
		
		Метод `values()` указывает, по каким полям нужно группировать объекты, а метод `annotate()` позволяет добавлять агрегированные значения к каждой группе. В приведенных примерах мы использовали функцию `Count('id')` для подсчета количества объектов в каждой группе, но вы также можете использовать другие функции агрегации, такие как `Sum`, `Avg`, `Max` и т. д.
		
		Таким образом, с помощью методов `values()` и `annotate()` вы можете выполнять операции GROUP BY в Django ORM и получать результаты агрегации данных по определенным полям.
7. **_В чем различие метода_** **_filter_** **_и_** **_exclude?_**
	
	Методы `filter()` и `exclude()` являются частями Django ORM и используются для фильтрации объектов в запросах к базе данных. Вот различия между ними:
	1) **Метод** `filter()`:
	    - `filter()` используется для определения условий, которым должны удовлетворять объекты, чтобы быть включенными в результирующий набор.
	    - Он выбирает объекты, которые соответствуют заданным условиям фильтрации.
	    - Пример:
			```python
			from myapp.models import Product
			# Выбрать все продукты с ценой больше 100
			products = Product.objects.filter(price__gt=100)
			```
	    - В этом примере, `filter()` выбирает все продукты, у которых цена (`price`)  больше 100.
	2) **Метод** `exclude()`:
	    - `exclude()` используется для исключения объектов, которые соответствуют заданным условиям, из результирующего набора.
	    - Он исключает объекты, которые удовлетворяют указанным условиям.
	    - Пример:
			```python
			from myapp.models import Product
			# Исключить все продукты с ценой меньше или равной 50
			products = Product.objects.exclude(price__lte=50)
			```
	    - В этом примере, `exclude()` исключает все продукты, у которых цена (`price`) меньше или равна 50.
	Используя `filter()` и `exclude()`, вы можете создавать более сложные запросы, комбинируя различные условия с помощью логических операторов (И, ИЛИ, НЕ). Если вы хотите выбрать объекты, которые удовлетворяют определенным условиям, используйте `filter()`. Если вы хотите исключить объекты, соответствующие заданным условиям, используйте `exclude()`.
8. **_Является ли класс мета в_** **_Django_** **_метаклассом?_**
	
	Нет, класс `Meta` в Django не является метаклассом. Класс `Meta` - это внутренний класс, используемый в моделях Django для предоставления метаданных о модели.
---

# **Django REST**

1. **_Какие вьюшки ты используешь?_**
	1) **APIView** 
		
		Это базовый класс представления, который предоставляет самый простой способ создания API-представлений в DRF. Я использую `APIView`, когда требуется полный контроль над обработкой запросов и не требуется автоматическое преобразование данных запроса и ответа.
	2) **GenericAPIView** 
		
		Это класс представления, который предоставляет расширенные функции для работы с моделями Django и автоматического преобразования данных запроса и ответа. Я использую `GenericAPIView` в ситуациях, когда нужно создать API-представление для одной модели и требуется стандартные операции CRUD (создание, чтение, обновление, удаление).
	3) **ViewSet** 
		
		Виды представлений (views) из класса `ViewSet` предоставляют ещё более удобный способ создания API-представлений, комбинируя различные операции CRUD в одном классе представления. Я использую `ViewSet`, когда нужно создать API-представления, которые обрабатывают различные операции, такие как получение списка объектов, создание объекта, получение конкретного объекта, обновление объекта и удаление объекта.
	4) **ModelViewSet** 
		
		Это класс представления, который предоставляет полную функциональность CRUD для модели Django в одном классе представления. `ModelViewSet` объединяет операции чтения, создания, обновления и удаления объектов в одном классе представления. Я использую `ModelViewSet`, когда нужно создать API-представление для модели Django, и требуется полная функциональность CRUD.
1. **_Какие плюсы использования вьюх написанных на классах?_**
	1) **Многоразовость кода**
		
		Классы представлений позволяют создавать модульные и многоразовые компоненты кода. Вы можете создать базовый класс представления с общей логикой и наследовать его для создания конкретных представлений. Это способствует повторному использованию кода и упрощает его поддержку и изменение.
	2) **Стандартизация операций**
		
		Классы представлений в DRF предоставляют стандартные методы для выполнения различных операций, таких как получение списка объектов, создание нового объекта, обновление объекта и удаление объекта. Это способствует единообразию и стандартизации вашего API.
	3) **Разделение логики**
		
		Классы представлений позволяют явно разделить различные аспекты логики, такие как обработка запросов, сериализация данных, валидация данных, авторизация и другие. Каждый аспект логики может быть реализован в отдельных методах класса представления, что облегчает понимание и поддержку кода.
	4) **Расширяемость и настраиваемость**
		
		Классы представлений позволяют легко настраивать и расширять их функциональность. Вы можете добавлять свои собственные методы и переопределять стандартные методы, чтобы адаптировать поведение представления под ваши требования. Это дает большую гибкость и контроль над вашими представлениями.
	5) **Поддержка mixins**
		
		В Django REST Framework есть множество готовых mixins - наборов поведения, которые можно легко добавлять к классам представлений. Это позволяет вам использовать предопределенные функции, такие как пагинация, фильтрация, сортировка, аутентификация и другие, просто добавляя соответствующие mixins к вашему классу представления.
	6) **Улучшенная читаемость и понимание**
		
		Классы представлений в DRF обычно имеют явную структуру и именование методов, что делает код более читаемым и понятным. Это особенно полезно при работе с более сложными операциями и логикой.
1. **_Что такое сериализаторы? Для чего они используются?_**
	
	Сериализаторы в Django REST Framework (DRF) - это компоненты, которые позволяют преобразовывать сложные типы данных, такие как модели Django, в форматы, которые легко передавать через сеть, такие как JSON. Они также обеспечивают обратное преобразование, то есть преобразование данных из формата, полученного от клиента, в объекты моделей.
---

# **Базы данных**

1. **_Какие типы баз данных ты знаешь? И чем они отличаются?_**
    
2. **_Какие плюсы_** **_PostgreSQL_** **_ты можешь выделить?_**
	
	PostgreSQL - мощная объектно-реляционная система управления базами данных (СУБД) с открытым исходным кодом. Вот некоторые плюсы, которые можно выделить при использовании PostgreSQL:
	1) **Надежность и целостность данных**
		
		PostgreSQL обеспечивает высокую надежность и целостность данных. Он поддерживает транзакции с ACID-свойствами (атомарность, согласованность, изолированность и долговечность), что гарантирует согласованность и безопасность ваших данных.
	2) **Расширяемость и гибкость**
		
		PostgreSQL предлагает множество возможностей для расширения функциональности базы данных. Он поддерживает создание пользовательских типов данных, пользовательских функций, хранимых процедур и других расширений. Это позволяет адаптировать СУБД под специфические потребности проекта.
	3) **Мощный язык запросов**
		
		PostgreSQL предоставляет мощный язык запросов, который поддерживает сложные запросы, агрегацию, оконные функции, CTE (общие таблицы выражений) и другие продвинутые возможности. Это позволяет эффективно извлекать и манипулировать данными из базы данных.
	4) **Поддержка геопространственных данных**
		
		PostgreSQL имеет встроенную поддержку геопространственных данных, что делает его отличным выбором для разработки географических приложений. Он предоставляет функции для работы с геометрическими объектами, выполнения пространственных запросов и анализа геоданных.
	5) **Масштабируемость**
		
		PostgreSQL может эффективно масштабироваться как по вертикали, добавляя более мощное оборудование, так и по горизонтали, с использованием репликации и шардинга данных. Это позволяет поддерживать высокую производительность и обработку большого объема данных.
	6) **Богатый набор функций**
		
		PostgreSQL предлагает богатый набор встроенных функций и типов данных, включая поддержку полнотекстового поиска, индексирование, аналитические функции, работу с массивами и JSON-данными, шифрование данных и многое другое. Это упрощает разработку сложных приложений и обработку различных типов данных.
	7) **Активное сообщество и поддержка**
3. **_Что такое индексы? И какие индексы ты знаешь?_**
    
    Индексы в контексте баз данных являются структурами данных, создаваемыми для ускорения поиска и извлечения данных из таблиц. Индексы обеспечивают быстрый доступ к данным, подобно алфавитному указателю в книге, где можно быстро найти страницу с нужной информацией.
    
	Некоторые известные типы индексов в базах данных:
	
	1) **B-деревья (B-trees)**
		
		B-деревья являются одной из самых распространенных структур индексов. Они обеспечивают эффективный поиск по ключам и хранятся в виде сбалансированного дерева. B-деревья подходят для широкого спектра операций поиска, таких как точное совпадение, диапазонные запросы и сортировка. 
	2) **Хеш-индексы (Hash indexes)**
		
		Хеш-индексы используют хеш-функции для быстрого поиска по значению ключа. Они обычно обеспечивают очень быстрый доступ к данным, но имеют ограничения в виде поддержки только точных совпадений и отсутствия поддержки диапазонных запросов.
	3. **GiST (Generalized Search Tree)**
		
		GiST - это общая структура данных для индексации, которая поддерживает различные типы поиска, включая геопространственные данные и текстовый поиск. Он предоставляет гибкую модель индексации, позволяя определять пользовательские операции и типы данных.
	4) **GIN (Generalized Inverted Index)**
		
		GIN - это структура индекса, специализированная на обработку поисковых запросов с полнотекстовым поиском и индексацией массивов. Она обеспечивает быстрый поиск по ключевым словам и поддерживает различные операции с массивами.
	5) **BRIN (Block Range INdex)**
		
		BRIN - это индекс, который разбивает данные на блоки и хранит сжатую информацию о минимальном и максимальном значении в каждом блоке. Он эффективно работает с большими таблицами, где данные упорядочены по ключу.
1. **_Какие join-ы ты знаешь? И расскажи про каждый из них поподробнее_**
    
    В SQL существует несколько типов операций объединения (join), которые позволяют объединять данные из нескольких таблиц на основе определенного условия. 
    
    Вот некоторые из наиболее распространенных типов join:
    
	1) **INNER JOIN**
		
		INNER JOIN возвращает только те строки, которые имеют совпадающие значения в объединяемых таблицах. Он использует условие сравнения для определения совпадений между таблицами и возвращает результат, содержащий только строки, удовлетворяющие этому условию. Пример использования INNER JOIN:
	    ```SQL
		SELECT Orders.OrderID, Customers.CustomerName
	    FROM Orders
	    INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
	    ```
	2) **LEFT JOIN**
		
		LEFT JOIN возвращает все строки из левой (первой) таблицы и соответствующие строки из правой (второй) таблицы. Если нет совпадений в правой таблице, то для соответствующих столбцов будет использовано значение NULL. Пример использования LEFT JOIN:
	    ```SQL
		SELECT Customers.CustomerName, Orders.OrderID
	    FROM Customers
	    LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
	    ```
	3) **RIGHT JOIN**
		
		RIGHT JOIN возвращает все строки из правой (второй) таблицы и соответствующие строки из левой (первой) таблицы. Если нет совпадений в левой таблице, то для соответствующих столбцов будет использовано значение NULL. Пример использования RIGHT JOIN:
		```SQL
		SELECT Customers.CustomerName, Orders.OrderID
	    FROM Customers
	    RIGHT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
	    ```
	4) **FULL JOIN**
		
		FULL JOIN объединяет результаты LEFT JOIN и RIGHT JOIN и возвращает все строки из обеих таблиц. Если нет совпадений в одной из таблиц, то для соответствующих столбцов будет использовано значение NULL. Пример использования FULL JOIN:    
	   ```SQL
		SELECT Customers.CustomerName, Orders.OrderID
	    FROM Customers
	    FULL JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
	    ```
	5) **CROSS JOIN**
		
		CROSS JOIN выполняет декартово произведение двух таблиц, то есть возвращает все возможные комбинации строк из обеих таблиц. Результатом является таблица, которая содержит все возможные комбинации строк. Пример использования CROSS JOIN:
	    ```SQL
	    SELECT Customers.CustomerName, Orders.OrderID
	    FROM Customers
	    CROSS JOIN Orders;
	    ```
	Это лишь некоторые из типов join, доступных в SQL. Каждый тип join предоставляет разные способы объединения данных из разных таблиц и позволяет выполнять различные операции с объединенными результатами. Выбор подходящего типа join зависит от требуемого результата и логики запроса.
5. **_Какие виды связи бывают между таблицами? И как они реализуются на уровне баз данных?_**
    
    На уровне баз данных, связи между таблицами обычно реализуются с помощью ключей, которые связывают значения одной таблицы с другой. Существуют различные типы связей, которые могут быть использованы в базах данных, включая:
	1) **Один к одному (One-to-One)**
		
		Это тип связи, при котором каждая запись в одной таблице связана с одной записью в другой таблице. Для реализации такой связи, обычно используется внешний ключ в одной из таблиц.  
	2) **Один ко многим (One-to-Many)**
		
		В этом типе связи каждая запись в одной таблице может быть связана с несколькими записями в другой таблице. Обычно внешний ключ добавляется в таблицу "многие" для указания на связанную запись в таблице "один".
	3) **Многие ко многим (Many-to-Many)**
		
		Это тип связи, при котором каждая запись в одной таблице может быть связана с несколькими записями в другой таблице, и наоборот. Для реализации такой связи создается третья таблица, называемая "таблицей-связью" или "промежуточной таблицей", которая содержит ключи обеих таблиц.
1. **_Что такое PrimaryKey?_**
	
	PrimaryKey (переводится как "первичный ключ") - это уникальный идентификатор, используемый для однозначной идентификации каждой записи в таблице базы данных. Он служит основным ключом для определения уникальности записей и обеспечивает быстрый доступ к данным. Основные характеристики PrimaryKey:
	
	1) **Уникальность**
		
		Каждое значение первичного ключа должно быть уникальным в пределах таблицы. Ни одно две записи не могут иметь одинаковое значение первичного ключа.
	2) **Неизменяемость**
		
		Значение первичного ключа не должно изменяться после его создания. Это гарантирует стабильность и однозначность идентификации записей.
	3) **Неотсутствие**
		
		Значение первичного ключа не может быть NULL или отсутствовать. Каждая запись в таблице должна иметь первичный ключ.
1. **_Constraints_** **_в базах данных?_**
    
    В контексте баз данных, ограничения (constraints) представляют собой правила, накладываемые на данные в таблице, чтобы гарантировать их целостность и согласованность. Constraints определяют различные ограничения и требования, которые должны быть соблюдены при добавлении, изменении или удалении данных. Ниже приведены некоторые распространенные типы ограничений, используемых в базах данных:
    
	1) **Primary Key Constraint (ограничение первичного ключа)**
		
		Определяет поле или набор полей, которые должны содержать уникальные идентификаторы для каждой записи в таблице. Primary key constraint обеспечивает уникальность идентификации записей и облегчает ссылочную целостность.    
	2) **Foreign Key Constraint (ограничение внешнего ключа)**
		
		Определяет связь между двумя таблицами на основе значения первичного ключа в одной таблице и соответствующего значения внешнего ключа в другой таблице. Foreign key constraint обеспечивает ссылочную целостность и поддерживает связи между таблицами.
	3) **Unique Constraint (ограничение уникальности)**
		
		Гарантирует, что значения в указанном поле или наборе полей являются уникальными для каждой записи в таблице. Unique constraint предотвращает дублирование данных и обеспечивает целостность данных.
	4) **Not Null Constraint (ограничение на непустое значение)** 
		
		Указывает, что определенное поле не может содержать значение NULL. Not null constraint требует, чтобы в поле было указано некоторое значение, предотвращая отсутствие необходимых данных.
	5) **Check Constraint (ограничение проверки)** 
		
		Позволяет определить пользовательское условие или выражение, которое должно быть истинным для каждой записи в таблице. Check constraint используется для проверки и ограничения допустимых значений или условий для полей.
1. **_Назови принципы_** **_ACID._**
    
    Принципы ACID - это набор основных принципов, которые определяют требования к транзакциям в базах данных. Акроним ACID расшифровывается следующим образом:
    
	1) **Atomicity (Атомарность)** 
		
		Транзакция должна быть атомарной, что означает, что она должна рассматриваться как единая неделимая операция. Все операции внутри транзакции должны быть выполнены полностью или не выполнены совсем. Если хотя бы одна операция внутри транзакции не может быть выполнена, то все изменения должны быть отменены (откат), чтобы вернуть базу данных в исходное состояние.
	2) **Consistency (Согласованность)** 
		
		Транзакция должна сохранять согласованность базы данных. Это означает, что после выполнения транзакции база данных должна оставаться в согласованном состоянии, соответствующем определенным правилам и ограничениям целостности данных.    
	3) **Isolation (Изолированность)** 
		
		Транзакции должны выполняться в изолированном режиме, то есть результаты одной транзакции не должны влиять на результаты других транзакций, выполняющихся параллельно. Изоляция обеспечивает, что каждая транзакция работает с данными, как будто она выполняется в отдельном изолированном пространстве.    
	4) **Durability (Долговечность)** 
		
		Результаты выполненной транзакции должны быть долговечными и сохранены в базе данных, даже в случае сбоев или отключения системы. Это означает, что данные, которые были успешно записаны в базу данных, должны оставаться доступными и не должны быть утрачены.
1. **_Расскажи про CAP теорему._**
    
    Теорема CAP (Consistency, Availability, Partition tolerance) - это теорема, описывающая ограничения, которые существуют при проектировании распределенных систем. Теорема CAP утверждает, что в условиях распределенной системы невозможно одновременно обеспечить все три свойства: согласованность (Consistency), доступность (Availability) и устойчивость к разделению (Partition tolerance).
    
	1) **Consistency (Согласованность)**
		
		Согласованность означает, что все копии данных в распределенной системе всегда находятся в согласованном состоянии. Это означает, что любое чтение данных из системы будет возвращать последнюю записанную версию данных или последнее обновление данных. При достижении согласованности система должна удовлетворять определенным правилам и ограничениям целостности данных.    
	2) **Availability (Доступность)**
		
		Доступность означает, что каждый запрос к распределенной системе должен получить ответ о результатах операции. Система должна быть доступна и готова обрабатывать запросы, даже в случае возникновения отказов или сбоев в системе. Доступность обеспечивает непрерывность работы системы и отказоустойчивость.    
	3) **Partition Tolerance (Устойчивость к разделению)**
		
		Устойчивость к разделению означает, что система продолжает функционировать, даже если возникают сетевые разделения (partitions) между узлами распределенной системы. Разделение может происходить в результате сбоев сети или задержек. Устойчивость к разделению позволяет системе продолжать работу и обеспечивает ее надежность.
1. **_Что такое нормализация и денормализация баз данных?_**
    
    Нормализация и денормализация - это два противоположных подхода к организации структуры базы данных.
    
	Нормализация - это процесс разделения данных в базе данных на отдельные таблицы с целью устранения избыточности данных и обеспечения целостности. Нормализация основана на наборе нормальных форм (например, первая нормальная форма (1NF), вторая нормальная форма (2NF), третья нормальная форма (3NF) и т.д.), которые определяют правила для устранения избыточности и повышения организации данных. Чем выше нормальная форма, тем больше требований предъявляется к структуре данных.
	
	Преимущества нормализации включают устранение избыточности, более легкое обновление и поддержку данных, а также лучшую защиту от аномалий и противоречий в данных. Однако, нормализация может привести к сложным запросам и объединениям таблиц для извлечения связанных данных.
	
	Денормализация - это процесс объединения таблиц или добавления избыточных данных в таблицы с целью увеличения производительности и упрощения запросов. Денормализация может использоваться в случаях, когда требуется быстрый доступ к данным или когда запросы часто объединяют несколько таблиц. При денормализации данные дублируются или комбинируются в одной таблице, чтобы избежать сложных операций объединения.
	
	Преимущества денормализации включают улучшенную производительность запросов, упрощенные запросы и снижение количества таблиц. Однако, денормализация может привести к избыточности данных, увеличению размера базы данных и потенциальным проблемам с целостностью данных при обновлении или изменении данных.
11. **_Назови уровни_** **_нормализации_** **_баз данных._**
    
	1) **Первая нормальная форма (1NF)** 
		
		Она требует, чтобы каждая ячейка в таблице содержала только одно значение, и каждая колонка имела уникальное имя. Также все значения в столбцах должны быть атомарными (неделимыми).
	2) **Вторая нормальная форма (2NF)**
		
		Вторая нормальная форма строится на основе 1NF и добавляет дополнительные требования. Она гарантирует, что каждый неключевой атрибут (столбец) в таблице полностью зависит от первичного ключа. То есть каждый неключевой атрибут должен зависеть только от первичного ключа, а не от других неключевых атрибутов.
	3) **Третья нормальная форма (3NF)**
		
		Третья нормальная форма строится на основе 2NF и дополнительно требует, чтобы каждый неключевой атрибут не зависел от других неключевых атрибутов. Она гарантирует, что нет транзитивных зависимостей между неключевыми атрибутами.
1. **_Какие уровни нормализации используются в_** **_PostgreSQL и какие в_** **_MySQL?_**
    
13. **_Проверить уровень знания_** **_SQL_** **_синтаксиса._**
    
14. **_Проверить уровень знания нереляционного синтаксиса._**
    
15. **_Какие нереляционные базы данных ты использовал? И в каких целях?_**
    
16. **_В каком формате данные хранятся в_** **_MongoDB_** **_и_** **_Redis?_**
    
17. **_Какие различия между_** **_MongoDB_** **_и_** **_Redis?_**
    
---

# **Docker**

1. ***Приходилось ли работать с** **Docker?***
    
    Docker - это открытая платформа, которая позволяет автоматизировать развертывание, масштабирование и управление приложениями в контейнерах. Контейнеры Docker представляют собой изолированные и портативные среды, в которых можно запускать приложения и их зависимости без проблем совместимости или конфликтов.
2. ***Что такое** **volume?***
    
    Volume (том) в Docker - это механизм, позволяющий сохранять и подключать данные к контейнерам. Он позволяет создавать постоянное хранилище данных в Docker-контейнере, которое может быть использовано как для чтения, так и для записи данных. В отличие от файлов, созданных в контейнере, данные в томах сохраняются и доступны, даже если контейнер удален или перезапущен.
3. ***Что такое** **layer?***
    
    В контексте Docker, слой (layer) - это концепция, используемая для организации файловой системы внутри образа контейнера. Образ контейнера состоит из набора слоев, где каждый слой представляет собой изменения, внесенные в файловую систему по сравнению с предыдущим слоем.
    
    Каждый слой содержит только изменения, сделанные относительно предыдущего слоя, и хранит только файлы и директории, которые были добавлены, изменены или удалены. Это делает слои контейнера легковесными и эффективными с точки зрения использования дискового пространства.
4. ***Что такое networks в** **Docker** **Compose?***
    
    В Docker Compose секция "networks" используется для определения пользовательских сетей (networks) в многоконтейнерной среде. С помощью этой секции можно создавать и настраивать сетевые окружения для ваших сервисов, объединяя контейнеры внутри определенных сетей и определяя свойства сетевого взаимодействия между ними.
    
    Секция "networks" в Docker Compose позволяет определить несколько сетей и связать сервисы с определенными сетевыми окружениями. Каждая сеть имеет свое имя, которое вы указываете в конфигурации сервиса. Когда контейнеры запускаются с использованием Docker Compose, они автоматически подключаются к указанным сетям.
    
    Использование сетей в Docker Compose предоставляет ряд преимуществ:
    
	1) **Изоляция сетей**
		
		Контейнеры, подключенные к разным сетям, могут быть изолированы друг от друга, что обеспечивает безопасность и разделение ресурсов.
	2) **Горизонтальное масштабирование**
		
		Сервисы, объединенные в одну сеть, могут легко масштабироваться путем добавления или удаления экземпляров контейнеров.
	3) **Чистота конфигурации**
		
		Определение сетей в Docker Compose позволяет явно указывать, какие контейнеры должны взаимодействовать между собой, что делает конфигурацию более понятной и управляемой.
	4) **Управление связями**
		
		Сети позволяют легко управлять связями между сервисами и контролировать, какие сервисы могут общаться друг с другом.
---  

#       БУДЕТ ПЛЮСОМ
# **Брокеры сообщений**

1. **_Приходилось ли использовать брокеры сообщений? И если да, то какие?_**
    
2. **_Внутреннее устройство_** **_RabbitMQ?_**
    
3. **_Внутреннее устройство_** **_Kafka?_**
    
4. **_Какие различия_** **_RabbitMQ_** **_и_** **_Kafka_** **_ты знаешь?_**
    
---

# **Архитектура приложений**

1. **_Какие архитектуры приложений ты знаешь?_**
    
2. **_Какие плюсы использования микросервисной архитектуры?_**
    
3. **_Способы построения общения между микросервисами?_**
    
4. **_В каком случае лучше использовать монолит?_**
    
5. **_Какие плюсы использования_** **_serverless_****_?_**
    
---

# **Облачные платформы**

1. **_Приходилось ли работать с облачными платформами? Если да, то с какими?_**
    
2. **_Расскажи про сервисы с которыми ты работал?_**
    
---

# **СI/CD**

1. **_Что такое_** **_CI_** **_и_** **_CD?_**
    
2. **_Какие инструменты используются при реализации_** **_CI_** **_и_** **_CD?_**
    
3. **_Работал ли с_** **_Kubernetes?_**
---
